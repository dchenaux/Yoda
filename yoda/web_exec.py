#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#  ██╗   ██╗ ██████╗ ██████╗  █████╗
#  ╚██╗ ██╔╝██╔═══██╗██╔══██╗██╔══██╗
#   ╚████╔╝ ██║   ██║██║  ██║███████║
#    ╚██╔╝  ██║   ██║██║  ██║██╔══██║
#     ██║   ╚██████╔╝██████╔╝██║  ██║
#     ╚═╝    ╚═════╝ ╚═════╝ ╚═╝  ╚═╝

"""
Web_exec is a visualisation module for the results generated by the analyser. It is provided inside a Flask instance
which can be either run directly by executing this script or also deployed on a webserver like Apache with mod_wsgi.
See Flask documentation for detailed informations about how to deploy an app.
"""

from collections import defaultdict, OrderedDict
import re
import json

from mongoengine import *

from flask import Flask, render_template, redirect, url_for, flash, jsonify
from flask_mongoengine import MongoEngine
from flask_debugtoolbar import DebugToolbarExtension

from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter

from yoda.docdef import *
import yoda.settings as settings


# Configuration of Flask App
app = Flask(__name__)
app.config['MONGODB_DB'] = settings.MONGODB
app.config['SECRET_KEY'] = "b\xac\xea&\x9d\x86\x98Da?\xcaL\x146\x13\x83\x82.$\x91\xee\x03\xe3\x95"
app.debug = True

# Debug toolbar configuration
app.config['DEBUG_TB_PANELS'] = [
    'flask_debugtoolbar.panels.versions.VersionDebugPanel',
    'flask_debugtoolbar.panels.timer.TimerDebugPanel',
    'flask_debugtoolbar.panels.headers.HeaderDebugPanel',
    'flask_debugtoolbar.panels.request_vars.RequestVarsDebugPanel',
    'flask_debugtoolbar.panels.template.TemplateDebugPanel',
    #'flask_debugtoolbar.panels.sqlalchemy.SQLAlchemyDebugPanel',
    'flask_debugtoolbar.panels.logger.LoggingPanel',
    'flask_debugtoolbar.panels.profiler.ProfilerDebugPanel',
    # Add the MongoDB panel
    'yoda.flask_debugtoolbar_mongo.panel.MongoDebugPanel',
]

toolbar = DebugToolbarExtension(app)
# End of Debug toolbar configuration

db = MongoEngine(app)

# End of Flask configuration

# Internal functions


def _colorize(files_object):
    for file in files_object:
        executed_lines = []
        for frame in file.frames:
            for line in frame.lines:
                executed_lines.append(line.lineno)
        file.content = highlight(
            file.content, PythonLexer(), HtmlFormatter(linenos=True, hl_lines=executed_lines, anchorlinenos=True))

    return files_object


def _serialize(file_objects):
    file_objects = json.loads(file_objects)
    for file in file_objects:
        for frame in file['frames']:
            serie = defaultdict(list)
            for line in frame['lines']:
                for k,v in line['data'].items():
                    serie[k].append(v)
            frame['objects'] = serie
            del frame['lines']

    return file_objects

def _file_fetch_data(file_id):
    series = {}
    file_object = File.objects(id=file_id)

    for file in file_object:
        serie = defaultdict(list)
        for frame in file.frames:
            for line in frame.lines:
                for k, listv in line.data.items():
                    for v in listv:
                        if type(v) is (int or float):
                            serie[k].append(v)
        series[file.id] = serie

    return file_object, series

def _gen_graph_data(file_objects, objects_list):

    file_objects = json.loads(file_objects)
    number_of_graphs = len(file_objects)-1
    current_graph = 0
    graphs = list()

    while current_graph <= number_of_graphs:
        var_list = set()
        series = list()

        # Get list of variables
        for frame in file_objects[current_graph]['frames']:
            for lines in frame['lines']:
                for var in lines['data']:
                    var_id = file_objects[current_graph]['_id']['$oid']+'-'+frame['name']+'-'+var
                    if objects_list == 'all':
                        var_list.add(var)
                    if  var_id in objects_list:
                        var_list.add(var)

        # Create the list of series
        for var in var_list:
            serie = OrderedDict()
            serie['name'] = var
            serie['data'] = list()
            series.append(serie)

        # Add data to the series
        steps = 0
        for frame in file_objects[current_graph]['frames']:
            # We make a loop for each line
            for lines in frame['lines']:
                steps_per_line = 0  # Start Counter
                # We loop for the keys and corresponding values
                for k, v in lines['data'].items():
                    steps_per_line = len(v)
                    for serie in series:
                        if serie['name'] == k:
                            if len(serie['data']) == 0:
                                for i in range(0, steps):
                                    serie['data'].append('null')
                            serie['data'] += v
                steps += steps_per_line

        current_graph += 1

        if number_of_graphs == 0 and objects_list == 'all':
            graphs = series
        else:
            graphs.append(series)

    return json.dumps(graphs)

@app.route('/_file_details/<file_id>')
def _file_details(file_id):
    file_objects = _serialize(
        File.objects(id=file_id).exclude("content","user","filename","timestamp", "revision").to_json())
    return json.dumps(file_objects)

@app.route('/_graph_data/<ids>')
def _graph_data(ids):
    if '-' not in ids:
        file_objects = _gen_graph_data(
            File.objects(id=ids).exclude("content", "user", "filename", "timestamp", "revision").to_json(), 'all')
        return json.dumps(file_objects)
    else :
        object_ids = re.split('&', ids)
        files_id = set()
        for object_id in object_ids:
            object_id = re.split('-', object_id)
            files_id.add(object_id[0])
        files_id = list(files_id)
        file_objects = _gen_graph_data(File.objects(id__in=files_id).exclude("content", "user", "filename", "timestamp", "revision").to_json(), object_ids)
        return json.dumps(file_objects)


# End of internal functions

# Flask pages
@app.route("/")
def index():
    """
    Index page of the application which lists all the runs made by the analyser
    :return: render the index.html template
    """
    return render_template('index.html', files=File.objects.exclude("frames", "content"))

@app.route("/view_file/<file_id>")
def view_file(file_id):
    """
    view_file page which gives detailed information about a single run
    :param file_id: passed in the url, unique identifier of a run
    :return: render the view_context.html template
    """

    file_object, series = _file_fetch_data(file_id)

    return render_template('view_file.html', file=_colorize(file_object), series=series)

@app.route("/view_context/<file_id>")
def view_context(file_id):
    """
    view_file page which gives detailed information about a single run
    :param file_id: passed in the url, unique identifier of a run
    :return: render the view_context.html template
    """

    file_object, series = _file_fetch_data(file_id)
    colorized = _colorize(file_object)
    for file in colorized:
        colorized_file = file


    return render_template('partials/view_context.html', file=colorized_file, series=series)


@app.route("/remove_files/<files_id>")
def remove_files(files_id):
    """
    Delete a run
    :param files_id: passed in the url, unique identifier of a run
    :return: redirects to index page
    """
    files_id = re.split('&', files_id)

    File.objects(id__in=files_id).delete()
    if len(files_id) == 1:
        flash('The entry %s was successfully deleted' % str(files_id).strip('[]'))
    else:
        flash('The entries %s were successfully deleted' % ', '.join(files_id))
    return redirect(url_for('index'))

@app.route("/compare_files/<files_id>")
def compare_files(files_id):
    files_id = re.split('&', files_id)
    files_object = File.objects(id__in=files_id).exclude("frames", "content")

    return render_template('compare_files.html', files=files_object)


if __name__ == "__main__":
    app.run()